use strict;
use warnings;

require 5.006000;

use ExtUtils::MakeMaker;
BEGIN { if ( $^O eq 'cygwin' ) {
  require ExtUtils::MM_Cygwin;
  require ExtUtils::MM_Win32;
  if ( ! defined(&ExtUtils::MM_Cygwin::maybe_command) ) {
    *ExtUtils::MM_Cygwin::maybe_command = sub {
      my ($self, $file) = @_;
      if ($file =~ m{^/cygdrive/}i and ExtUtils::MM_Win32->can('maybe_command')) {
        ExtUtils::MM_Win32->maybe_command($file);
      } else {
        ExtUtils::MM_Unix->maybe_command($file);
      }
    }
  }
}}

my $mymeta_works = eval { ExtUtils::MakeMaker->VERSION('6.5707'); 1 };
my $mymeta = $mymeta_works || eval { ExtUtils::MakeMaker->VERSION('6.5702'); 1 };

my %META_BITS = (
);
my %RUN_DEPS = (
  'Sub::Exporter' => 0,
);

my %WriteMakefileArgs = (
  NAME                => 'Devel::GlobalDestruction',
  VERSION_FROM        => 'lib/Devel/GlobalDestruction.pm',
  LICENSE             => 'perl',
  INSTALLDIRS         => 'site',
  PL_FILES            => { },
  MIN_PERL_VERSION    => '5.006000',
  PREREQ_PM           => \%RUN_DEPS,
  CONFIGURE_REQUIRES  => { 'ExtUtils::CBuilder' => 0.27 },
  META_ADD => {
    resources => {
      homepage => 'http://search.cpan.org/dist/Devel-Globaldestruction',
      repository => 'git://git.shadowcat.co.uk/p5sagit/Devel-Globaldestruction.git',
      bugtracker => 'http://rt.cpan.org/Public/Dist/Display.html?Name=Devel-Globaldestruction',
    },
    requires => \%RUN_DEPS,
  },
  ($mymeta and !$mymeta_works) ? ( 'NO_MYMETA' => 1 ) : (),
  ( (defined ${^GLOBAL_PHASE} or !can_xs() )
    ? (XS => {}, C => [])
    : ()
  ),
);

unless ( eval { ExtUtils::MakeMaker->VERSION('6.56') } ) {
  my $br = delete $WriteMakefileArgs{BUILD_REQUIRES};
  my $pp = $WriteMakefileArgs{PREREQ_PM};
  for my $mod ( keys %$br ) {
    if ( exists $pp->{$mod} ) {
      $pp->{$mod} = $br->{$mod} if $br->{$mod} > $pp->{$mod};
    }
    else {
      $pp->{$mod} = $br->{$mod};
    }
  }
}

delete $WriteMakefileArgs{CONFIGURE_REQUIRES}
  unless eval { ExtUtils::MakeMaker->VERSION('6.52') };

WriteMakefile(%WriteMakefileArgs);

# can we locate a (the) C compiler
sub can_cc {
  my @chunks = split(/ /, $Config::Config{cc}) or return;

  # $Config{cc} may contain args; try to find out the program part
  while (@chunks) {
    return can_run("@chunks") || (pop(@chunks), next);
  }

  return;
}

# check if we can run some command
sub can_run {
  my ($cmd) = @_;

  return $cmd if -x $cmd;
  if (my $found_cmd = MM->maybe_command($cmd)) {
    return $found_cmd;
  }

  require File::Spec;
  for my $dir ((split /$Config::Config{path_sep}/, $ENV{PATH}), '.') {
    next if $dir eq '';
    my $abs = File::Spec->catfile($dir, $cmd);
    return $abs if (-x $abs or $abs = MM->maybe_command($abs));
  }

  return;
}

# Can our C compiler environment build XS files
sub can_xs {
  # Do we have the configure_requires checker?
  local $@;
  eval "require ExtUtils::CBuilder; ExtUtils::CBuilder->VERSION(0.27)";
  if ( $@ ) {
    # They don't obey configure_requires, so it is
    # someone old and delicate. Try to avoid hurting
    # them by falling back to an older simpler test.
    return can_cc();
  }

  # Do we have a working C compiler
  my $builder = ExtUtils::CBuilder->new(
    quiet => 1,
  );
  unless ( $builder->have_compiler ) {
    # No working C compiler
    return 0;
  }

  # Write a C file representative of what XS becomes
  require File::Temp;
  my ( $FH, $tmpfile ) = File::Temp::tempfile(
    "compilexs-XXXXX",
    SUFFIX => '.c',
  );
  binmode $FH;
  print $FH <<'END_C';
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

int main(int argc, char **argv) {
    return 0;
}

int boot_sanexs() {
    return 1;
}

END_C
  close $FH;

  # Can the C compiler access the same headers XS does
  my @libs   = ();
  my $object = undef;
  eval {
    local $^W = 0;
    $object = $builder->compile(
      source => $tmpfile,
    );
    @libs = $builder->link(
      objects     => $object,
      module_name => 'sanexs',
    );
  };
  my $result = $@ ? 0 : 1;

  # Clean up all the build files
  foreach ( $tmpfile, $object, @libs ) {
    next unless defined $_;
    1 while unlink;
  }

  return $result;
}
